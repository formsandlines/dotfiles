#+TITLE: GNU Emacs Config
#+AUTHOR: Peter Hofmann
#+DESCRIPTION: Peterâ€™s personal Emacs config.
#+STARTUP: showeverything
#+OPTIONS: toc:2

* IMPORTANT PROGRAMS TO LOAD FIRST
** Custom File

#+begin_src elisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

** Package Manager

#+begin_src elisp
(setq package-archives 
      '(("melpa" . "https://melpa.org/packages/")
        ("elpa" . "https://elpa.gnu.org/packages/")))

;;; Bootstrap use-package:
;; (package-initialize)                ; ? still needed
;; (setq use-package-always-pin "nongnu") ; ? is this important
(setq use-package-always-ensure t)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile (require 'use-package)) ; ? needed
#+end_src

*use-package autoremove fix*

Custom ~package-autoremove~ that only removes packages not ~:ensure~'d in
~use-package~ declarations by building a custom list that overrides
~package-selected-packages~.

Normally, ~use-package~ should add (via ~:ensure~) auto-installed packages to
~package-selected-packages~, but it seems like they are added only as
dependencies, which causes ~package-autoremove~ to remove them, hence the fix.
- may be fixed properly in the future (hopefully?), then this snippet can be
  removed
- [[https://github.com/jwiegley/use-package/issues/870#issuecomment-771881305][Source]] (GitHub)
#+begin_src elisp
(defvar use-package-selected-packages '(use-package)
  "Packages pulled in by use-package.")
(defun use-package-autoremove ()
  "Autoremove packages not used by use-package."
  (interactive)
  (let ((package-selected-packages use-package-selected-packages))
    (package-autoremove)))

(eval-and-compile
  (define-advice use-package-handler/:ensure (:around (fn name-symbol keyword args rest state) select)
    (let ((items (funcall fn name-symbol keyword args rest state)))
      (dolist (ensure args items)
        (let ((package
               (or (and (eq ensure t) (use-package-as-symbol name-symbol))
                   ensure)))
          (when package
            (when (consp package)
              (setq package (car package)))
            (push `(add-to-list 'use-package-selected-packages ',package) items))))))
  (define-advice use-package-handler/:quelpa (:around (fn name-symbol keyword args rest state) select)
    (let ((package (pcase (car args)
                     ((pred symbolp) (car args))
                     ((pred listp) (car (car args))))))
      (cons `(add-to-list 'use-package-selected-packages ',package)
            (funcall fn name-symbol keyword args rest state)))))
#+end_src

** Includes

#+begin_src elisp
(require 'org-tempo)
#+end_src

* Personal information
#+begin_src elisp
(setq user-full-name "Peter Hofmann"
      user-mail-address "peter.hofmann@formsandlines.eu")
#+end_src

* Packages
** use-package add-ons
Enable ~:diminish~ to hide modeline display of some minor modes:
#+begin_src elisp
(use-package diminish)
#+end_src
** meow (test)
*** Custom meow commands
#+begin_src elisp
;; Let 'a' in 'normal' mode behave like 'a' in Vi:
;; - https://github.com/meow-edit/meow/discussions/497#discussioncomment-6713192
(defun ph/meow-append ()
  "Move to the end of selection, switch to INSERT state."
  (interactive)
  (if meow--temp-normal
      (progn
        (message "Quit temporary normal mode")
        (meow--switch-state 'motion))
    (if (not (region-active-p))
        (when (and (not (use-region-p))
                   (< (point) (point-max)))
          (forward-char 1))
      (meow--direction-forward)
      (meow--cancel-selection))
    (meow--switch-state 'insert)))

(defun ph/meow-line-append ()
  "Appends to the end of the current line."
  (interactive)
  (meow-end-of-thing (meow-line 1))
  (meow-append))

(defun ph/meow-line-insert ()
  "Inserts at the beginning (indentation) of the current line."
  (interactive)
  (meow-beginning-of-thing (meow-line 1))
  (meow-insert))

(defun ph/meow-join-with ()
  "Joins current line with line below."
  (interactive)
  (meow-join -1)
  (meow-kill))

(defun ph/meow-split-at ()
  "Splits current line at point."
  (interactive)
  (electric-newline-and-maybe-indent))

#+end_src

*** My meow things
#+begin_src elisp
(defun ph/meow-things ()
  ;; (meow-thing-register 'quoted
  ;;                      '(regexp "`" "`\\|'")
  ;;                      '(regexp "`" "`\\|'"))
  
  (meow-thing-register 'angle
                       '(pair ("<") (">"))
                       '(pair ("<") (">")))

  (setq meow-char-thing-table
	'((?f . round)
          (?d . square)
          (?s . curly)
          (?a . angle)
          (?r . string)
          (?w . paragraph)
          (?e . line)
          (?q . buffer))))
#+end_src
*** My meow bindings
- modified from [[https://github.com/meow-edit/meow/issues/506#issuecomment-1730789625][Source]] (Final final version (22. Sept.))
#+begin_src elisp
(defun ph/meow-bindings ()
  
  (meow-define-keys 'insert
    '("ESC" . meow-insert-exit)
    '("C-p" . meow-yank))
  
  (meow-motion-overwrite-define-key
   '("i" . meow-prev)
   '("k" . meow-next)
   '("j" . meow-left)
   '("l" . meow-right)
   '("v" . ph/scroll-up-half)
   '("V" . ph/scroll-down-half)
   '("{" . backward-paragraph)
   '("}" . forward-paragraph)
   '("<escape>" . ignore))

  (meow-leader-define-key
   ;; Window commands
   '("wc" . delete-window)        ;; C-x 0
   '("wd" . delete-other-windows) ;; C-x 1
   '("ws" . split-window-below)   ;; C-x 2
   '("wv" . split-window-right)   ;; C-x 3
   '("ww" . other-window)	  ;; C-x o
    ;; Move Windows
   '("w J" . buf-move-left)
   '("w K" . buf-move-down)
   '("w I" . buf-move-up)
   '("w L" . buf-move-right)

   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet)

   ;; SPC j/k/l/h will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   '("l" . "H-l")
   '("i" . "H-i")
   '("v" . "H-v")
   '("V" . "H-V")
   '("{" . "H-{")
   '("}" . "H-}"))

  (meow-define-keys 'beacon
    '("nm" . meow-beacon-start)
    '("ne" . meow-beacon-apply-kmacro))

  ;; -------------------- ;;
  ;;       MAPPINGS       ;;
  ;; -------------------- ;;
  (meow-define-keys 'normal
					; expansion
    '("0" . meow-expand-0)
    '("1" . meow-expand-1)
    '("2" . meow-expand-2)
    '("3" . meow-expand-3)
    '("4" . meow-expand-4)
    '("5" . meow-expand-5)
    '("6" . meow-expand-6)
    '("7" . meow-expand-7)
    '("8" . meow-expand-8)
    '("9" . meow-expand-9)
    '(";" . meow-reverse)		; ' -> ;

					; movement
    '("i" . meow-prev)
    '("k" . meow-next)
    '("j" . meow-left)
    '("l" . meow-right)

    '("v" . ph/scroll-up-half)
    '("V" . ph/scroll-down-half)

    '("/" . meow-search)		; y -> / -> ` -> /

					; expansion
    '("I" . meow-prev-expand)
    '("K" . meow-next-expand)
    '("J" . meow-left-expand)
    '("L" . meow-right-expand)

    '("u" . meow-back-word)
    '("U" . meow-back-symbol)
    '("o" . meow-next-word)
    '("O" . meow-next-symbol)

    '("w" . meow-mark-word)		; a -> w
    '("W" . meow-mark-symbol)		; A -> W
    '("e" . meow-line)			; s -> e
    '("E" . ph/meow-line-append)
    '("q" . meow-block)			; w -> q
    '("Q" . meow-to-block)
    '("a" . meow-join)			; q -> a
    '("A" . ph/meow-line-insert)
    '("g" . meow-grab)			; g -> h (see undo) -> g
    '("G" . meow-pop-grab)		; G -> H -> G
    '("m" . meow-swap-grab)
    '("M" . meow-sync-grab)
    '("H" . meow-cancel-selection)	; p -> [ -> t -> h -> H
    '("h" . meow-pop-selection)		; P -> { -> T -> H -> h
    '("t" . meow-transpose-sexp)
    '("T" . transpose-lines)

    '("F" . meow-till)			; x -> t -> F
    '("f" . meow-find)			; z -> f

    '("[" . meow-beginning-of-thing)	; , -> [
    '("]" . meow-end-of-thing)		; . -> ]
    '("," . meow-inner-of-thing)	; < -> ,
    '("." . meow-bounds-of-thing)	; > -> .

    '("{" . backward-paragraph)
    '("}" . forward-paragraph)

					; editing
    '("d" . meow-kill)
    '("D" . meow-kill-whole-line)
    '("c" . meow-change)		; f -> c
    '("C" . meow-replace)
    '("x" . meow-delete)		; t -> x
    '("`" . meow-save)			; c -> y -> t -> `
    '("p" . meow-yank)			; v -> p
    '("P" . meow-yank-pop)		; V -> P

    '("s" . meow-insert)		; e -> s
    '("S" . meow-open-below)		; E -> S
    '("r" . ph/meow-append)		; Vi-style append
    '("R" . meow-open-above)		; S -> R

    '("z" . undo-only)			; h -> g -> z (because Vi habits)
    '("Z" . undo-redo)			; H -> G -> Z

    '("b" . open-line)
    '("B" . split-line)

    '("=" . meow-indent)
    '("X" . ph/meow-join-with)

    ;; '("[" . indent-rigidly-left-to-tab-stop)
    ;; '("]" . indent-rigidly-right-to-tab-stop)

					; prefix n
    '("nc" . meow-comment)		; nf -> nc
    '("nn" . meow-start-kmacro-or-insert-counter)
    '("nm" . meow-start-kmacro)
    '("ne" . meow-end-or-call-kmacro)
    '("n`" . kill-ring-save)
    '("np" . yank)
    '("ns" . meow-visit)	        ; / -> ? -> / -> ns
    '("n+" . ph/increment-number-at-point)
    '("n-" . ph/decrement-number-at-point)
    '("ng" . meow-goto-line)		; S -> E -> ng
    ;; '("nj" . ph/meow-join-with)
    ;; '("nk" . ph/meow-split-at)
    ;; ...etc

					; prefix ; -> \
    '("\\w" . save-buffer)		; ;f -> ;w -> \w
    '("\\W" . save-some-buffers)	; ;F -> ;W -> \W
    '("\\d" . meow-query-replace-regexp) ; ;d -> \d
    ;; ... etc

    					; special
    '("-" . negative-argument)
    '("'" . repeat)
    '("N" . meow-paren-mode)

					; ignore escape
    '("<escape>" . ignore))
)
#+end_src

*** My meow paren state:
#+begin_src elisp
(defun ph/meow-paren-setup ()
  (setq meow-paren-keymap (make-keymap))
  (meow-define-state paren
    "meow state for structural editing"
    :lighter " [P]"
    :keymap meow-paren-keymap)

  ;; meow-define-state creates the variable
  (setq meow-cursor-type-paren 'hollow)

  (meow-define-keys 'paren
    '("ESC" . meow-normal-mode)
    '("<backspace>" . sp-backward-unwrap-sexp)

    '("e" . sp-end-of-sexp)
    '("a" . sp-beginning-of-sexp)
    '("z" . meow-undo)
    '("t" . meow-save)
    
    '("j" . sp-backward-sexp)
    '("J" . sp-backward-symbol)
    '("k" . sp-down-sexp)
    '("i" . sp-up-sexp)
    '("l" . sp-forward-sexp)
    '("L" . sp-forward-symbol)
    
    '("K" . sp-backward-down-sexp)
    '("I" . sp-backward-up-sexp)
    
    '("d" . sp-kill-sexp)
    '("D" . sp-kill-hybrid-sexp)

    '("r" . sp-raise-sexp)
    '("t" . sp-transpose-sexp)
    '("c" . sp-convolute-sexp)
    '("s" . sp-splice-sexp)
    '("S" . sp-split-sexp)
    '("o" . sp-join-sexp)
    '("=" . sp-indent-defun)
    '("/" . sp-comment)
    '(";" . repeat)

    '("O" . sp-next-sexp)
    '("o" . sp-select-next-thing)
    '("U" . sp-previous-sexp)
    '("u" . sp-select-previous-thing)

    '("p" . meow-yank)
    '("a" . meow-append)
    '("." . sp-forward-slurp-sexp)
    '(">" . sp-forward-barf-sexp)
    '("<" . sp-backward-barf-sexp)
    '("," . sp-backward-slurp-sexp)
    '("g" . meow-cancel-selection)

    '("`" . sp-unwrap-sexp)
    ;; use prefix instead? e.g. "s r" for wrap round
    ;; or use leader key to make available everywhere?
    '("[" . (lambda () (interactive) (sp-wrap-with-pair "[")))
    '("{" . (lambda () (interactive) (sp-wrap-with-pair "{")))
    '("(" . (lambda () (interactive) (sp-wrap-with-pair "("))))
)
#+end_src
*** Meow package
#+begin_src elisp
(use-package meow
  :ensure t
  :demand t
  :config
  (meow-global-mode 1)
  (meow-setup-indicator)

  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)

  (ph/meow-things)
  (ph/meow-paren-setup)
  (ph/meow-bindings))
#+end_src
** COMMENT Evil

Vim style undo not needed for emacs 28
#+begin_src elisp
;; (use-package undo-fu)
#+end_src

Vim bindings
#+begin_src elisp
(use-package evil
  :ensure t
  :demand t
  :bind (("<escape>" . keyboard-escape-quit))
  :init
  ;;; allows for using cgn
  ;; (setq evil-search-module 'evil-search)
  (setq evil-want-keybinding nil)
  (setq evil-want-Y-yank-to-eol t)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-undo-system 'undo-redo)
  ;; (setq evil-want-C-u-scroll t) ; use â€˜\ C-uâ€™ instead for â€˜universal-argumentâ€™
  ;;; no vim insert bindings
  ;; (setq evil-undo-system 'undo-fu)
  :config
  (evil-mode 1)
  (define-key evil-normal-state-map (kbd "C-b") #'evil-scroll-up)
  (define-key evil-normal-state-map (kbd "C-f") #'evil-scroll-down)
  (define-key evil-normal-state-map (kbd "M-b") #'evil-scroll-page-up)
  (define-key evil-normal-state-map (kbd "M-f") #'evil-scroll-page-down)
  (define-key evil-normal-state-map (kbd "Â§") #'evil-ex-nohighlight))

;;; Compile warnings:
;; Warning (bytecomp): â€˜evil-member-recursive-ifâ€™ is an obsolete function (as of 1.15.0).
;; Warning (bytecomp): â€˜evil-want-visual-char-semi-exclusiveâ€™ is an obsolete variable (as of 1.15.0); Semi-exclusivity prevents selecting text + 1st char of next line,
;; without having to introduce new niche functionality.
;; Prefer to set â€˜evil-v$-excludes-newlineâ€™ to non-nil.
#+end_src

TODO Evil:
- [ ] set evil-scroll-up keybinding
- [ ] Vim window switching commands?
- [ ] how does transpose work
- [ ] visible yanking
- [ ] counting up/down with C-a / C-x?
- [ ] how to get (/) to jump around parens?
- [ ] fix paste in insert-mode
- [ ] enter in table cell should edit

Leader key functionality?
- [ ] ~space+[/]~ instead of C-[ C-] to insert lines
- [ ] space+b instead of C-x b to switch buffer

Vim Bindings Everywhere else
#+begin_src elisp
(use-package evil-collection
  :ensure t
  :after evil
  :init (evil-collection-init)
  :config
  (setq evil-want-integration t))

(use-package evil-org
  :ensure t
  :after (evil org)
  :hook (org-mode . evil-org-mode)
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))

;;; Compiler warnings:
;; Warning (bytecomp): the function â€˜evil-org-org-insert-todo-subheading-belowâ€™ is not known to be defined.
;; Warning (bytecomp): the function â€˜evil-org-org-insert-todo-heading-belowâ€™ is not known to be defined.
;; Warning (bytecomp): the function â€˜evil-org-org-insert-todo-heading-respect-content-belowâ€™ is not known to be defined.
;; Warning (bytecomp): the function â€˜evil-org-org-insert-heading-respect-content-belowâ€™ is not known to be defined.
#+end_src

surround.vim emulation:
#+begin_src elisp
(use-package evil-surround
  :ensure t
  :after evil
  :config
  (global-evil-surround-mode 1))
#+end_src

Comments with ~gcc~ / ~gc~:
#+begin_src elisp
(use-package evil-commentary
  :ensure t
  :diminish
  :after evil
  :config
  (evil-commentary-mode))
#+end_src

** Version control
#+begin_src elisp
(use-package magit
  :ensure t)

(use-package diff-hl
  :after (magit dired)
  :ensure t
  :diminish
  :init
  (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
  :config
  (global-diff-hl-mode)
  (add-hook 'dired-mode-hook 'diff-hl-dired-mode))

#+end_src

** Keybinding helper
*** COMMENT General keybindings
/(thanks to DistroTube for sharing!)/

#+begin_src elisp
(use-package general
  :ensure t
  :config
  (general-evil-setup)

  ;; set up 'SPC' as the global leader key
  (general-create-definer ph/leader-keys
                          :states '(normal insert visual emacs)
                          :keymaps 'override
                          :prefix "SPC" ;; set leader
                          :global-prefix "M-SPC") ;; access leader in insert mode

  (ph/leader-keys
    "." '(find-file :wk "Find file")
    "TAB TAB" '(comment-line :wk "Comment lines")
    "SPC" '(org-fill-paragraph :wk "Correct line wrap")
    "[" '(newline-empty-above :wk "Insert newline above")
    "]" '(newline-empty-below :wk "Insert newline below"))

  (ph/leader-keys
    "f" '(:ignore t :wk "file")
    "f c" '(visit-init :wk "Edit Emacs config")
    "f b" '(recentf-open-files :wk "Recent files buffer")
    "f r" '(recentf-open :wk "Recent files"))

  (ph/leader-keys
    "b" '(:ignore t :wk "buffer")
    "b b" '(switch-to-buffer :wk "Switch buffer")
    "b i" '(ibuffer :wk "Ibuffer")
    "b k" '(kill-this-buffer :wk "Kill this buffer")
    "b n" '(next-buffer :wk "Next buffer")
    "b p" '(previous-buffer :wk "Previous buffer")
    ;; "b r" '(revert-buffer :wk "reload buffer")
    )

  (ph/leader-keys
    "e" '(:ignore t :wk "Evaluate")    
    "e b" '(eval-buffer :wk "Evaluate elisp in buffer")
    "e d" '(eval-defun :wk "Evaluate defun containing or after point")
    "e e" '(eval-expression :wk "Evaluate and elisp expression")
    "e l" '(eval-last-sexp :wk "Evaluate elisp expression before point")
    "e r" '(eval-region :wk "Evaluate elisp in region")) 

   (ph/leader-keys
    "h" '(:ignore t :wk "Help")
    "h f" '(describe-function :wk "Describe function")
    "h v" '(describe-variable :wk "Describe variable")
    "h r r" '((lambda () (interactive) (load-file user-init-file)) :wk "Reload emacs config")) ;; may need to call it twice because of some issue

   (ph/leader-keys
    "w" '(:ignore t :wk "Windows")
    ;; Window splits
    "w c" '(evil-window-delete :wk "Close window")
    "w n" '(evil-window-new :wk "New window")
    "w s" '(evil-window-split :wk "Horizontal split window")
    "w v" '(evil-window-vsplit :wk "Vertical split window")
    ;; Window motions
    "w h" '(evil-window-left :wk "Window left")
    "w j" '(evil-window-down :wk "Window down")
    "w k" '(evil-window-up :wk "Window up")
    "w l" '(evil-window-right :wk "Window right")
    "w w" '(evil-window-next :wk "Goto next window")
    ;; Move Windows
    "w H" '(buf-move-left :wk "Buffer move left")
    "w J" '(buf-move-down :wk "Buffer move down")
    "w K" '(buf-move-up :wk "Buffer move up")
    "w L" '(buf-move-right :wk "Buffer move right"))

   (ph/leader-keys
    "t" '(:ignore t :wk "Toggle")
    "t l" '(display-line-numbers-mode :wk "Toggle line numbers")
    "t h" '(hl-line-mode :wk "Toggle line highlighting")
    "t t" '(visual-line-mode :wk "Toggle truncated lines")))
#+end_src

*** which-key
#+begin_src elisp
(use-package which-key
  :ensure t
  :init
  (which-key-mode 1)
  :config
  ;; (setq which-key-side-window-location 'bottom)
  ;; (setq which-key-sort-order #'which-key-key-order-alpha)
  ;; (setq which-key-sort-uppercase-first nil)
  ;; (setq which-key-add-column-padding 1)
  ;; (setq which-key-max-display-columns nil)
  ;; (setq which-key-min-display-lines 6)
  ;; (setq which-key-side-window-slot -10)
  ;; (setq which-key-side-window-max-height 0.25)
  ;; (setq which-key-idle-delay 0.8)
  ;; (setq which-key-max-description-length 25)
  ;; (setq which-key-allow-imprecise-window-fit t)
  ;; (setq which-key-separator " â†’ ")
  )
#+end_src

** OrgMode extensions
#+begin_src elisp
(use-package org-appear
  :ensure t
  :diminish
  :after org
  :hook org-mode
  :config
  (setq org-appear-autoentities t)
  (setq org-appear-autolinks t)
  (setq org-appear-autosubmarkers t))
#+end_src

** Snippets
#+begin_src elisp
(use-package yasnippet
  :ensure t
  :diminish
  :config
  (yas-global-mode 1))
#+end_src

** Appearance
#+begin_src elisp
(use-package rainbow-mode
  :diminish
  :hook org-mode prog-mode)
#+end_src

#+begin_src elisp
;; (use-package gruvbox-theme
;;   :config
;;   (load-theme 'gruvbox))

;;; good theme for customization
;; (load-theme 'modus-vivendi)
#+end_src

** Completion
#+begin_src elisp
;; Enable rich annotations using the Marginalia package
(use-package marginalia
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  :bind (:map minibuffer-local-map
	      ("M-A" . marginalia-cycle))

  ;; The :init section is always executed.
  :init

  ;; Marginalia must be activated in the :init section of use-package such that
  ;; the mode gets enabled right away. Note that this forces loading the
  ;; package.
  (marginalia-mode)

  :config
  (setq marginalia-field-width 80) ; 43 in Doom
  
  (add-hook 'icomplete-minibuffer-setup-hook
	    (lambda () (setq truncate-lines t)))
  
  (add-hook 'completion-list-mode-hook
	    (lambda () (setq truncate-lines t)))

  ;;; Disable Marginalia in *completions* buffer for non-one-column formats
  ;; -> doesnâ€™t work
  ;; - https://github.com/minad/marginalia/issues/129
  ;; (defun disable-marginalia ()
  ;;   (when (and (equal t fido-mode)
  ;; 	       (not (eq completions-format 'one-column)))
  ;;     (setq-local marginalia-annotator-registry nil)))
  ;; (add-hook 'completion-list-mode-hook #'disable-marginalia)
  )
#+end_src

** Programming

*dumb-jump* (jump to definition, etc. (file searchers for xref)
#+begin_src elisp
(use-package dumb-jump
  :ensure t
  :diminish
  :init (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))

;;; Compiler Warnings:
;; Warning (bytecomp): â€˜point-at-bolâ€™ is an obsolete function (as of 29.1); use â€˜line-beginning-positionâ€™ or â€˜pos-bolâ€™ instead.
;; Warning (bytecomp): the function â€˜xref-make-file-locationâ€™ is not known to be defined.
;; Warning (bytecomp): the function â€˜xref-makeâ€™ is not known to be defined.
;; Warning (bytecomp): the function â€˜firstâ€™ is not known to be defined.
;; Warning (bytecomp): the function â€˜tramp-dissect-file-nameâ€™ is not known to be defined.
;; Warning (bytecomp): the function â€˜tramp-file-name-localnameâ€™ is not known to be defined.
;; Warning (bytecomp): the function â€˜helm-make-sourceâ€™ is not known to be defined.
;; Warning (bytecomp): the function â€˜ivy-readâ€™ is not known to be defined.
#+end_src

*Flycheck* (linter)
#+begin_src elisp
(use-package flycheck
  :ensure t
  :defer t
  :diminish
  :init (global-flycheck-mode))

(use-package flycheck-clj-kondo
  :ensure t
  :after flycheck
  :diminish)
#+end_src

*Company* (text completion)
#+begin_src elisp
(use-package company
  :ensure t
  :defer t
  :diminish
  :init (add-hook 'after-init-hook 'global-company-mode))

;;; ? needed
;; (use-package company-box
;;   :after company
;;   :diminish
;;   :hook (company-mode . company-box-mode))
#+end_src

** Structural editing
*** smartparens
#+begin_src elisp
(use-package smartparens
  :ensure t
  :init (require 'smartparens-config)
  :config
  (smartparens-global-mode t) ;; These options can be t or nil.
  (show-smartparens-global-mode t)
  (setq sp-show-pair-from-inside t))
#+end_src
*** COMMENT lispy
#+begin_src elisp
(use-package lispy
  :ensure t
  :hook ((emacs-lisp-mode clojure-mode lisp-mode) . lispy-mode)
  ;; :config
  ;; (eval-after-load "lispy"
  ;;   `(progn
  ;;      (lispy-define-key lispy-mode-map "S" 'special-lispy-visit)))
  )
#+end_src
*** COMMENT lispyville
#+begin_src elisp
(use-package lispyville
  :ensure t
  :demand t
  :after (lispy evil)
  :hook (lispy-mode . lispyville-mode)
  :config
  (lispyville-set-key-theme
   '(operators
     text-objects
     additional-motions
     c-w
     slurp/barf-lispy
     additional)))
#+end_src

** Language support
#+begin_src elisp
(use-package haskell-mode
  :ensure t)

(use-package lua-mode
  :ensure t)


(use-package cider
  :ensure t
  :config
  (require 'flycheck-clj-kondo)
  ;; for better editing in camelCase (Java names):
  (add-hook 'cider-repl-mode-hook #'subword-mode))

;;; CIDER Warnings:
;; evil-collection-cider.el:31:11: Warning: Package cl is deprecated
;; ../../../cider-1.11.0/cider-mode.el: Warning: Missing format argument
;; Warning (evil-collection): Make sure to set `evil-want-keybinding' to nil before loading evil or evil-collection.

(use-package clj-refactor
  :ensure t
  :after cider
  :config
  ;;; Hook function from https://github.com/clojure-emacs/clj-refactor.el
  (add-hook 'clojure-mode-hook
	    (lambda ()
	      (clj-refactor-mode 1)
	      (yas-minor-mode 1) ; for adding require/use/import statements
	      ;; This choice of keybinding leaves cider-macroexpand-1 unbound
	      (cljr-add-keybindings-with-prefix "C-c C-m"))))

#+end_src

* GUI tweaks
#+begin_src elisp
(setq inhibit-startup-message t)

(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

* Basic config
#+begin_src elisp
;;; Display relative line numbers
(setq display-line-numbers-type 'relative)
(global-display-line-numbers-mode 1)
(setq display-line-numbers-widen t)
(setq display-line-numbers-width-start t)
(setq display-line-numbers-width 3)

;;; Display column number in modeline
(column-number-mode 1)

;;; Highlight current line
(hl-line-mode 1)

;;; Disable tab insertion for indentation
(setq indent-tabs-mode nil)

;;; Set max char count for automatic line breaks
(setq-default fill-column 80) ; ! FIXME: still 70?
;;; Display vertical line at char limit
(global-display-fill-column-indicator-mode 1)
(setq display-fill-column-indicator-character 9474)
;;; Automatically insert line breaks at char limit
;; (auto-fill-mode 1)

(setq repeat-mode t)
(setq repeat-exit-key "<return>")

(setq sentence-end-double-space nil)

(setq next-screen-context-lines 4) ;; was 2

(setq blink-cursor-mode nil)

;;; Remember and get back to recently opened files
(recentf-mode 1)

;;; Remember and restore the last cursor location of opened files
(save-place-mode 1)
;;; Save and restore the state of Emacs from one session to another
(desktop-save-mode 1)

;;; Donâ€™t pop up UI dialogs when prompting
(setq use-dialog-box nil)

;;; Revert buffers when the underlying file has changed
(global-auto-revert-mode 1)
;;; Revert Dired and other buffers
(setq global-auto-revert-non-file-buffers t)

;;; Disabled by default, but I find them useful and not confusing:
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)

;;; No backup files (foo.txt~):
(setq make-backup-files nil)

;;; Follow symlinks for version control:
(setq vc-follow-symlinks t)
#+end_src

* Buffer move
Creating some functions to allow us to easily move windows (splits) around. The
following block of code was taken from =buffer-move.el= found on the EmacsWiki:
- https://www.emacswiki.org/emacs/buffer-move.el
- [[https://gitlab.com/dwt1/configuring-emacs/-/blob/main/03-shells-terms-and-theming/config.org][Source (DistroTube)]]

#+begin_src elisp
;;;###autoload
(defun buf-move-up ()
  "Swap the current buffer and the buffer above the split.
If there is no split, ie now window above the current one, an
error is signaled."
;;  "Switches between the current buffer, and the buffer above the
;;  split, if possible."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'up))
	 (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No window above this one")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun buf-move-down ()
"Swap the current buffer and the buffer under the split.
If there is no split, ie now window under the current one, an
error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'down))
	 (buf-this-buf (window-buffer (selected-window))))
    (if (or (null other-win) 
            (string-match "^ \\*Minibuf" (buffer-name (window-buffer other-win))))
        (error "No window under this one")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun buf-move-left ()
"Swap the current buffer and the buffer on the left of the split.
If there is no split, ie now window on the left of the current
one, an error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'left))
	 (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No left split")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun buf-move-right ()
"Swap the current buffer and the buffer on the right of the split.
If there is no split, ie now window on the right of the current
one, an error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'right))
	 (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No right split")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))
#+end_src

* Customization
** Modifier keys
#+begin_src elisp
(setq mac-command-modifier 'meta)          ;; left cmd = right cmd
(setq mac-right-command-modifier 'left)
(setq mac-option-modifier nil)             ;; keeps Umlauts, etc. accessible
(setq mac-right-option-modifier 'left)
(setq mac-control-modifier 'hyper)         ;; in case hyper is needed
(setq mac-right-control-modifier 'control) ;; also works for caps-lock as ctrl

#+end_src

** Some keyboard shortcuts
#+begin_src elisp
;; (global-set-key (kbd "C-c C-r") 'recentf-open-files)
;; (global-set-key (kbd "C-c r") 'recentf-open)


;;; because M-x is hard to reach on my keyboard:
(global-set-key (kbd "C-\\") 'execute-extended-command)
(global-set-key (kbd "C-|") 'execute-extended-command-for-buffer)
(global-set-key (kbd "M-+") 'toggle-input-method) ;; replacement for C-\

(global-set-key [remap list-buffers] 'ibuffer)


;;; because C-M-d activates the dictionary in MacOS (hard to change):
(global-set-key (kbd "C-M-'") 'down-list) 

;;; I like to scroll line-by-line
(defun ph/scroll-one-line-up () (interactive) (scroll-up 1))
(defun ph/scroll-one-line-down () (interactive) (scroll-down 1))

;;; For some reason these conflict with meow-kill:
;; (global-set-key (kbd "C-j") 'ph/scroll-one-line-up)
;; (global-set-key (kbd "C-k") 'ph/scroll-one-line-down)

(defun ph/window-half-height ()
  (max 1 (/ (1- (window-height (selected-window))) 2)))

(defun ph/scroll-up-half ()
  (interactive)
  (scroll-up (ph/window-half-height)))

(defun ph/scroll-down-half ()         
  (interactive)                    
  (scroll-down (ph/window-half-height)))

;; (global-set-key (kbd "C-j") 'ph/scroll-up-half)
;; (global-set-key (kbd "C-k") 'ph/scroll-down-half)

;; (add-hook 'org-mode-hook
;; 	  (lambda ()
;; 	    (define-key org-mode-map (kbd "C-j") 'ph/scroll-one-line-up)))
;; (add-hook 'org-mode-hook
;; 	  (lambda ()
;; 	    (define-key org-mode-map (kbd "C-k") 'ph/scroll-one-line-down)))

;; (defun my-org/insert-heading-above ()
;;   "Insert a heading above the current one and activate Evil insert mode."
;;   (interactive)
;;   (if (org-at-heading-p)
;;       (evil-first-non-blank)
;;     (org-up-element))
;;   (org-insert-heading)
;;   (evil-insert-state))

;; (evil-define-key 'normal org-mode-map (kbd "C-S-<return>")
;;  'my-org/insert-heading-above)


(defun describe-keybinding (keybinding)
  (interactive "sEnter keybinding: ")
  (describe-key (kbd keybinding)))

;;; Use if a keybinding in minibuffer is not accessible from the system:
;; (setq enable-recursive-minibuffers t)  ; <-- set to nil after use!
;; (define-key minibuffer-mode-map (kbd "C-M-k") 'describe-keybinding)

#+end_src
** Minibuffer / Completion
#+begin_src elisp
;;; Remember history of minibuffer prompts
(setq history-length 25)
(savehist-mode 1)

(setq completions-format 'horizontal)
(setq completion-auto-wrap t) ;; wraps around when navigating completions
(setq completion-auto-help t)
(setq completion-auto-select 'second-tab)
(setq completion-show-help nil) ;; hides help message

(define-key minibuffer-mode-map (kbd "C-n") 'minibuffer-next-completion)
(define-key minibuffer-mode-map (kbd "C-p") 'minibuffer-previous-completion)

(define-key completion-in-region-mode-map (kbd "C-n")
	    'minibuffer-next-completion)
(define-key completion-in-region-mode-map (kbd "C-p")
	    'minibuffer-previous-completion)
 
;;; Completion system
(fido-mode 1)
;; (fido-vertical-mode 1)

;; because M-x <up> is awkward:
(define-key icomplete-fido-mode-map (kbd "C-r")
	    #'minibuffer-complete-history)
#+end_src

** Visit config file
#+begin_src elisp
(defun visit-init ()
  "Opens the init.el file."
  (interactive)
  (find-file (locate-user-emacs-file "config.org")))

(global-set-key (kbd "C-x c") 'visit-init)
#+end_src

** OrgMode config

#+begin_src elisp
;;; Hide emphasis marker characters
(setq org-use-speed-commands t)

;;; Enable org-indent-mode on startup
(setq org-startup-indented t)

(setq org-hide-emphasis-markers t)
;;; Show entities as UTF8 characters
(setq org-pretty-entities t)

;; (setq org-startup-with-latex-preview t)

;; (setq org-edit-src-content-indentation 0)
(setq org-src-preserve-indentation t)
#+end_src


Fix for ~org-fill-paragraph~ in ~org-indent-mode~, which fails to integrate the
indentation. Overrides ~current-fill-column~ to ensure the correct
calculation.
- credits to patrick: https://emacs.stackexchange.com/a/74973

#+begin_src elisp
(defun current-fill-column ()
      "Return the fill-column to use for this line.
Subtracts right margin and org indentation level from fill-column"
      (let ((indent-level (if (bound-and-true-p org-indent-mode)
                              (* org-indent-indentation-per-level
                                 (org-current-level))
                            0))
            (margin (or (get-text-property (point) 'right-margin) 0)))
        (- fill-column indent-level margin)))
#+end_src

** Line creating and joining/breaking
#+begin_src elisp
(defun newline-empty-below ()
  "Creates a newline below the point that is always empty."
  (interactive)
  (let ((beg (point)))
    (move-end-of-line nil)
    (open-line 1)
    (goto-char beg)))

(defun newline-empty-above ()
  "Creates a newline above the point that is always empty."
  (interactive)
  (let ((beg (point)))
    (back-to-indentation)
    (open-line 1)
    (goto-char beg)))

(global-set-key (kbd "C-}") 'newline-empty-below)
(global-set-key (kbd "C-{") 'newline-empty-above)


(defun join-with-next-line ()
  "Join the current line with the line after it."
  (interactive)
  (join-line -1))

;;; Feels more like Vims S-j to me and I use this very often:
;;; (note: C-j gets overwritten in Lisp Interactive mode)
(global-set-key (kbd "C-M-j") 'delete-indentation) ;; M-^ is weird to type
(global-set-key (kbd "C-S-j") 'join-with-next-line) ; ? or C-c j

;;; I donâ€™t use these often enough for their prominent keybindings:
(global-set-key (kbd "M-o") 'default-indent-new-line) ;; was C-M-j / M-j
(global-set-key (kbd "M-j") 'electric-newline-and-maybe-indent) ;; was C-j

#+end_src

** Shells & Terminals
shell-mode:
#+begin_src elisp
;;; TODO: bind to local key
(defun comint-kill-output ()
  "In shell-mode, kills output instead of deleting, as in
comint-delete-output by default (C-c C-o)."
  (interactive)
  (comint-delete-output t))
#+end_src

eshell:
#+begin_src elisp
(setq eshell-history-size 5000
      eshell-buffer-maximum-lines 5000
      ; eshell-hist-ignoredups t
      eshell-scroll-to-bottom-on-input t
      ; eshell-destroy-buffer-when-process-dies t  ;; WARNING: see variable info
      ; eshell-visual-commands'("bash" "htop" "ssh" "top" "zsh")
      )
#+end_src

** Popup windows & Help buffers
#+begin_src elisp
(defun ph/close-all-popups ()
  "Closes all open popup windows."
  (interactive)
  (dolist (window (window-list))
    (when (window-parameter window 'popup)
      (delete-window window))))

(defun ph/kill-all-help-buffers ()
  "Closes all open help buffers."
  (interactive)
  (let ((buffers (cl-remove-if-not
                  (lambda (b) (string-prefix-p "*Help" (buffer-name b) t))
                  (buffer-list))))
    (dolist (buf buffers)
      (when (buffer-live-p buf)
        (when (get-buffer-window buf)
          ;; Delete window if more than one window is open
          (when (> (length (window-list)) 1)
            (delete-window (get-buffer-window buf))))
        (kill-buffer buf)))))

(global-set-key (kbd "C-`") 'ph/kill-all-help-buffers)
#+end_src

** Colors

Find nearest color
Source: https://www.masteringemacs.org/article/find-nearest-colors-emacs-24
#+begin_src elisp
(defun find-nearest-color (color &optional use-hsv)
  "Finds the nearest color by RGB distance to COLOR.

If called with a universal argument (or if USE-HSV is set) use HSV instead of RGB.
Runs \\[list-colors-display] after setting `list-colors-sort'"
  (interactive "sColor: \nP")
  (let ((list-colors-sort `(,(if (or use-hsv current-prefix-arg)
                                 'hsv-dist
                               'rgb-dist) . ,color)))
    (if (color-defined-p color)
        (list-colors-display)
      (error "The color \"%s\" does not exist." color))))

(defun find-nearest-color-at-point (pt)
  "Finds the nearest color at point PT.

If called interactively, PT is the value immediately under `point'."
  (interactive "d")
  (find-nearest-color (with-syntax-table (copy-syntax-table (syntax-table))
                        ;; turn `#' into a word constituent to help
                        ;; `thing-at-point' find HTML color codes.
                        (modify-syntax-entry ?# "w")
                        (thing-at-point 'word))))
#+end_src

** Windows
#+begin_src elisp
;; (defun window-full ()
;;   (interactive)
;;   (enlarge-window 1))
#+end_src

** Misc
Increment/decrement numbers like in Vim:
- see https://www.emacswiki.org/emacs/IncrementNumber
#+begin_src elisp
(defun ph/change-number-at-point (change increment)
  (let ((number (number-at-point))
        (point (point)))
    (when number
      (progn
        (forward-word)
        (search-backward (number-to-string number))
        (replace-match (number-to-string (funcall change number increment)))
        (goto-char point)))))

(defun ph/increment-number-at-point (&optional increment)
  "Increment number at point like vim's C-a"
  (interactive "p")
  (ph/change-number-at-point '+ (or increment 1)))

(defun ph/decrement-number-at-point (&optional increment)
  "Decrement number at point like vim's C-x"
  (interactive "p")
  (ph/change-number-at-point '- (or increment 1)))

(global-set-key (kbd "C-c +") 'ph/increment-number-at-point)
(global-set-key (kbd "C-c -") 'ph/decrement-number-at-point)
#+end_src

* Appearance
** Fonts
#+begin_src elisp
(set-face-attribute 'default nil
                    :font "Berkeley Mono"
                    :height 130 ;; 12 pt
                    :weight 'regular)

(set-face-attribute 'variable-pitch nil
                    :font "Cambria"
                    :height 120
                    :weight 'regular)

(set-face-attribute 'fixed-pitch nil
                    :font "Berkeley Mono"
                    :height 130
                    :weight 'regular)

(set-face-attribute 'font-lock-comment-face nil
                    :slant 'italic)

(set-face-attribute 'font-lock-keyword-face nil
                    :slant 'normal)

(setq-default line-spacing 0.12)
#+end_src

** Theme
#+begin_src elisp
(add-to-list 'custom-theme-load-path (concat user-emacs-directory "themes"))
(load-theme 'pmacs t)
#+end_src

* TODO

To practice:
- [ ] OrgMode bindings (+ Evil ones)
- [ ] leader-key bindings

To learn:
- [ ] learn keybinding in general
- [ ] then learn how to use general.el
- [ ] how to use localleader with general.el
- [ ] how does Yasnippet work and is it useful?
- [ ] CIDER

Packages to try:
- [ ] Ivy for completion instead of FIDO?
  - see [[https://gitlab.com/dwt1/configuring-emacs/-/blob/main/03-shells-terms-and-theming/config.org?ref_type=heads#ivy-counsel][DistroTube]] for config
- [ ] Swiper (depends on ivy) for isearch with regex
- [ ] all-the-icons and all-the-icons-nerd-fonts
  - see [[https://gitlab.com/dwt1/configuring-emacs/-/blob/main/03-shells-terms-and-theming/config.org?ref_type=heads#all-the-icons][DistroTube]] for config
- [ ] sudo-edit if need arises to use sudo to open files
- [ ] consider vterm instead of ~M-x shell~
  - seems to be compiled instead of elisp -> faster
  - see [[https://gitlab.com/dwt1/configuring-emacs/-/blob/main/03-shells-terms-and-theming/config.org?ref_type=heads#vterm][DistroTube]] for config
  - also install vterm-toggle
- [ ] does dump-jump (installed) work?

  
* Eshell alias file
This doesnâ€™t work somehow if I put it in =eshell/alias=!

#+begin_src shell
# Credits to DistroTube for config inspiration:
# https://gitlab.com/dwt1/configuring-emacs/-/blob/main/03-shells-terms-and-theming/eshell/aliases?ref_type=heads

# Aliases for emacs commands
alias ff find-file $1

# Aliasing standard shell commands to better emacs alternatives
alias less view-file $1

# Changing "ls" to "exa"
alias ls exa -al --color=always --group-directories-first $*  # my preferred listing
alias la exa -a --color=always --group-directories-first $*   # all files and dirs
alias ll exa -l --color=always --group-directories-first $*   # long format
alias lt exa -aT --color=always --group-directories-first $*  # tree listing
alias l. exa -a1 $* | grep "^\."                              # list hidden files

# Merge Xresources (what is this?)
# alias merge xrdb -merge ~/.Xresources

# Confirm before overwriting something
alias cp cp -i $1
alias mv mv -i $1
alias rm rm -i $1

# Bare git repo alias for dotfiles (not sure if I want this yet)
# alias config /usr/bin/git --git-dir=$HOME/dotfiles --work-tree=$HOME $*
#+end_src

